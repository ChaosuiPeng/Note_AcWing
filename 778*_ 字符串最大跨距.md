### 778. 字符串最大跨距
有三个字符串 S,S1,S2，其中，S 长度不超过 300，S1 和 S2 的长度不超过 10。

现在，我们想要检测 S1 和 S2 是否同时在 S 中出现，且 S1 位于 S2 的左边，并在 S 中互不交叉（即，S1 的右边界点在 S2 的左边界点的左侧）。

计算满足上述条件的最大跨距（即，最大间隔距离：最右边的 S2 的起始点与最左边的 S1 的终止点之间的字符数目）。

如果没有满足条件的 S1，S2 存在，则输出 −1。

例如，S= abcd123ab888efghij45ef67kl, S1= ab, S2= ef，其中，S1 在 S 中出现了 2 次，S2 也在 S 中出现了 2 次，最大跨距为：18。

**输入格式**

输入共一行，包含三个字符串 S,S1,S2，字符串之间用逗号隔开。

数据保证三个字符串中不含空格和逗号。

**输出格式**
输出一个整数，表示最大跨距。

如果没有满足条件的 S1 和 S2 存在，则输出 −1。

**输入样例：** 

abcd123ab888efghij45ef67kl,ab,ef

**输出样例：** 

18

### 思路
输入：给定三个字符串s, s1和s2。三个字符串用逗号隔开，且确保字符串中不包含空格和逗号。

要求检测： （1）s1和s2同时在s中同时出现（可能出现多次）；

          （2）s1位于s2的左边； 
          
          （3）s1和s2不重叠
          
输出：一个整数，表示s1和s2的最大间隔距离。若条件不符合，则输出-1。


思路：找到最左边的s1和最右边的s2，看看他们的位置关系（s1在s2的左边），看看有没有重叠，再求他们之间的最大跨距。 

怎么找位置：我们有s1和s2的长度，通过对比判断第一个字符，去s.substr对比是不是我们要的s1或者s2，保存第一个s1的位置p1以及最后一个s2的位置p2。注意在移动比对位置的指针i的时候，每次要往前移动多少。 

### 代码
```c++
#include <iostream>

using namespace std;

int main()
{
	// 处理用逗号隔开的三个字符串的输入 
	string s_input;
	cin >> s_input;
	
	string s, s1, s2;
	int k = 0;
	while(s_input[k] != ',') s += s_input[k++];
	while(s_input[++k] != ',') s1 += s_input[k];
	while(++k < s_input.size()) s2 += s_input[k];
	
	int len_s = s.size(), len_s1 = s1.size(), len_s2 = s2.size();
	
	// 找最左s1和最右s2的位置 
	int p1 = -1, p2 = -1;
	for (int i = 0; i < len_s; i ++)
	{
		// s1只需要找第一个。判断i有无越界。字符串是否匹配。
		// 匹配成功后i往后挪s1.size()个位置（s2一定在s1后面） 
		if (p1 < 0
			&& i + len_s1 < len_s
			&& s[i] == s1[0] && s.substr(i, len_s1) == s1)
		{
			p1 = i;
			i += len_s1;
		}
		
		// 在找到s1的情况下才找s2。判断i有无越界。字符串是否匹配。
		// 匹配成功后，正常i++，不需要考虑往后移动s2.size()个位置 
		if (p1 >= 0 
			&& i + len_s2 <= len_s
			&& s[i] == s2[0] && s.substr(i, len_s2) == s2) p2 = i;
	}

	if (p1 >= 0 && p2 > 0) cout << p2 - (p1 + len_s1 - 1) - 1 << endl;
	else cout << -1 << endl;
	
	return 0;
} 
```
